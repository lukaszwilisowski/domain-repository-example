# IDomainRepository - PostgreSQL example

## How to use domain-repository

### 1. Define your domain models

Make sure you have domain models defined. Each model should be exported in two versions:

- `Detached` (default model without id), for objects not yet persisted in the database
- `Attached` (with id), for already persisted objects

This differentiation improves intellisense and debugging. You can call your models whatever you like, as long as you stick to your naming convention. Our recommendation is to add _Attached suffix_ to all of your attached models.

For example:

```typescript
//We recommend to use IType naming convention for pure model types, to distinguish them from classes
export type ICar = {
  name: string;
  best: boolean;
  readonly yearOfProduction: number;
  sold?: Date;
};

export type ICarAttached = ICar & { id: string };
```

An attached model will contain:

- at minimum, a string Id [(why Id is of type string?)](https://github.com/lukaszwilisowski/domain-repository/blob/main/DISCUSSION.md#6-why-object-id-should-be-of-type-string)
- other properties auto-generated by the db engine (not manually assignable)

---

### 2. Use IDomainRepository in your business services

Use `IDomainRepository`\* interface in places, where you would previously use Mongoose collection or TypeORM repository. Type it explicitly with your standard and Attached model type.

\*If you only need to read or write data you can also use narrowed versions of interfaces: `IReadDomainRepository` or `IWriteDomainRepository` (SOLID's Interface segregation principle).

```typescript
import { IDomainRepository } from 'domain-repository';

export class CarService {
  constructor(private readonly carRepository: IDomainRepository<ICar, ICarAttached>) {}

  public async create(car: ICar): Promise<ICarAttached> {
    return this.carRepository.create(car);
  }

  public async findBestCar(): Promise<ICarAttached | undefined> {
    return this.carRepository.findOne({ best: true });
  }
}
```

---

### 3. Write unit tests (Test-driven-development)

Here lies the greatest benefit of using IDomainRepository. You can easily test your services using MockedDbRepository implementation. **No more difficult mocking of db methods!**

```typescript
import { MockedDBRepository } from 'domain-repository';

describe('CarService', () => {
  const initialData: ICarAttached[] = [
    { id: '1', name: 'Volvo', best: false, yearOfProduction: 2000 },
    {
      id: '2',
      name: 'Toyota',
      best: true,
      yearOfProduction: 2010,
      sold: new Date()
    }
  ];

  const mockedRepository = new MockedDBRepository<ICar, ICarAttached>(initialData);
  const carService = new CarService(mockedRepository);

  it('should find best car', async () => {
    const car = await carService.findBestCar();

    expect(car).toBeDefined();
    expect(car!.name).toEqual('Toyota');
  });
});
```

Your testers will no longer have to know the technical details of your db implementation. The unit testing has never been easier.

---

### 4. Choose your DB technology and define model mappings.

Let's say I want to use PostgreSQL as my DB, and TypeORM as my ORM layer.

Let's create a new file for my DB model, for example: `car.entity.ts`:
Because we have mappings, this does not have to be the same model as domain model.

```typescript
export type ICarSqlEntity = {
  id: number;
  name: string;
  best_of_all: boolean;
  readonly yearOfProduction: number;
  sold?: Date;
};
```

Now create file `car.entity.ts` and define your db entity, using TypeORM:

```typescript
import { mapToSqlIntId } from 'domain-repository/db/postgresql';
import { Mapping } from 'domain-repository/mapping';

//you can put ! next to the properties, to prevent Typescript no-initializer warnings
@Entity('cars')
export class SqlCarEntity implements ICarSqlEntity {
  @PrimaryGeneratedColumn()
  readonly id!: number;

  @Column('text')
  name!: string;

  @Column('bool')
  best_of_all!: boolean;

  @Column('int')
  readonly yearOfProduction!: number;

  @Column('text', { nullable: true })
  sold?: Date;
}

export const sqlCarMapping: Mapping<ICarAttached, ICarSqlEntity> = {
  id: mapToSqlIntId,
  name: 'name',
  best: 'best_of_all',
  yearOfProduction: 'yearOfProduction',
  sold: 'sold'
};
```

If you are interested, `mapToSqlIntId` has a simple implementation:

```typescript
export const mapToSqlIntId: TransformProperty<'id', string, number> = MapTo.Property(
  'id',
  (objectId: string) => parseInt(objectId),
  (entityId: number) => entityId.toString()
);
```

Please note that our Mapping allows for more advanced transformations, such as:

- a property can be mapped to other property with compatible type but different name, using direct assignment: `property: 'mappedProperty'`
- a primitive property can be mapped to other primitive property of different type, using transformation helper `MapTo.Property(mappedProperty, transformFunc, reverseTransformFunc)`
- an array of primitives property can be mapped to other array of primitives, using single element transformation helper `MapTo.Array(mappedProperty, transformElementFunc, reverseTransformElementFunc)`
- an object array property can be mapped to other object array property, using nested mapping `MapTo.ObjectArray(mappedProperty, nestedMapping)`
- a nested object property can be mapped to other nested object property, using nested mapping `MapTo.NestedObject(mappedProperty, nestedMapping)`

You can find an example of advanced nested object mapping [here](https://github.com/lukaszwilisowski/domain-repository/blob/main/test/db/mongodb/entities/car/car.entity.ts) and [here](https://github.com/lukaszwilisowski/domain-repository/blob/main/test/object-entity-mapper/_models/example.mapping.ts).

---

### 5. Supply your services with proper repository implemenation for your target DB.

Now depending on your db and ORM layer, you need to create ORM repository and pass it to our implementation of IDomainRepository.

PostgreSQL example:

```typescript
import { PostgreSQLDbRepository } from 'domain-repository/db/postgresql';

const runPostgresTest = async (): Promise<void> => {
  const dataSource = new DataSource({
    type: 'postgres',
    host: 'localhost',
    port: 5432,
    database: 'mydb',
    username: 'postgres',
    password: 'admin',
    synchronize: true, //for local testing
    entities: [SqlCarEntity]
  });

  await dataSource.initialize();

  const carRepository = new PostgreSQLDbRepository<ICar, ICarAttached, ICarSqlEntity>(
    dataSource.getRepository(SqlCarEntity),
    sqlCarMapping
  );

  const carService = new CarService(carRepository);

  await carService.create({
    name: 'Toyota',
    best: true,
    yearOfProduction: 2010,
    sold: new Date()
  });

  const bestCar = await carService.findBestCar();
  console.log(bestCar);
};

runPostgresTest();
```

Output:

```bash
{
  id: '146',
  name: 'Toyota',
  best: true,
  yearOfProduction: 2010,
  sold: '2023-01-06T13:11:43.685+01:00'
}
```

PostgreSQL data (see best_of_all renamed property):

```
id,"name","best_of_all","yearOfProduction","sold"
146,"Toyota",True,2010,"2023-01-06T13:11:43.685+01:00"
```
